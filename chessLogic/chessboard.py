from . import moves # Importa el m칩dulo 'moves' que contiene las reglas geom칠tricas de movimiento.
from . import rules # Importa el m칩dulo 'rules' que contiene reglas de ajedrez como jaque, enroque, etc.
from .move import Move # Importa la clase 'Move' para representar un movimiento.
from chessLogic.utils import get_all_moves # Importa la funci칩n para obtener todos los movimientos posibles.
from chessLogic.rules import ChessRules # Importa la clase ChessRules para acceder a sus m칠todos est치ticos.

class ChessBoard:
    def __init__(self):
        # Inicializa el tablero de ajedrez con la configuraci칩n inicial de las piezas.
        # Cada elemento es una cadena de 2 caracteres: color (w/b) + tipo de pieza (r/n/b/q/k/p).
        # "--" representa una casilla vac칤a.
        self.board = [
            ["br", "bn", "bb", "bq", "bk", "bb", "bn", "br"], # Fila 0: Piezas negras
            ["bp"] * 8,                                     # Fila 1: Peones negros
            ["--"] * 8,                                     # Fila 2: Vac칤a
            ["--"] * 8,                                     # Fila 3: Vac칤a
            ["--"] * 8,                                     # Fila 4: Vac칤a
            ["--"] * 8,                                     # Fila 5: Vac칤a
            ["wp"] * 8,                                     # Fila 6: Peones blancos
            ["wr", "wn", "wb", "wq", "wk", "wb", "wn", "wr"]  # Fila 7: Piezas blancas
        ]
        self.turn = "w" # El turno inicial es para las blancas ('w').
        self.en_passant_square = None   # 游댳 Casilla donde es posible un en passant. Se actualiza despu칠s de un movimiento de pe칩n doble.
        # Derechos de enroque para cada rey y torre. True si es posible, False si ya se movi칩 la pieza.
        self.castling_rights = {"wK": True, "wQ": True, "bK": True, "bQ": True}
        self.white_king_pos = (7, 4) # Posici칩n inicial del rey blanco.
        self.black_king_pos = (0, 4) # Posici칩n inicial del rey negro.

        # 游댳 nuevo: log de movimientos para poder deshacerlos.
        self.move_log = []

        # 游댳 opcional: log de derechos de enroque para poder restaurarlos en undo.
        self.castling_rights_log = [self.castling_rights.copy()]

    def get_piece(self, row, col):
        """
        Devuelve la pieza en la casilla especificada (row, col).
        """
        return self.board[row][col]

    def is_valid_move(self, start_pos, end_pos, color_override=None):
        """
        Verifica si un movimiento es legal, considerando las reglas del ajedrez y si deja al rey en jaque.
        
        Args:
            start_pos (tuple): Tupla (fila, columna) de la casilla de inicio.
            end_pos (tuple): Tupla (fila, columna) de la casilla de destino.
            color_override (str, optional): Permite forzar la validaci칩n para un color espec칤fico.
                                            칔til para la IA. Por defecto, usa el turno actual.
        
        Returns:
            bool: True si el movimiento es v치lido, False en caso contrario.
        """
        start_row, start_col = start_pos
        piece = self.board[start_row][start_col]

        # Color que se usa para validar (puede forzarse con override).
        color = color_override if color_override else self.turn

        # Si no hay pieza en la casilla de inicio o la pieza no es del color correcto, el movimiento es inv치lido.
        if piece == "--" or piece[0] != color:
            return False

        # Validar reglas geom칠tricas (c칩mo se mueve la pieza) y movimientos especiales (enroque, en passant).
        # Si no es un movimiento geom칠tricamente legal y tampoco es un movimiento especial, es inv치lido.
        if not moves.is_legal_move(self, start_pos, end_pos):
            if not rules.ChessRules.is_special_move(self, start_pos, end_pos):
                return False

        # --- Simular el movimiento para verificar si el rey queda en jaque ---
        temp_piece = self.board[end_pos[0]][end_pos[1]] # Guarda la pieza en la casilla de destino (por si es una captura).
        self.board[end_pos[0]][end_pos[1]] = piece      # Mueve la pieza a la casilla de destino.
        self.board[start_row][start_col] = "--"         # Vac칤a la casilla de inicio.

        # Actualizar temporalmente la posici칩n del rey si la pieza movida es un rey.
        old_king_pos = None
        if piece[1] == "k": # Si la pieza movida es un rey.
            old_king_pos = self.white_king_pos if piece[0] == "w" else self.black_king_pos # Guarda la posici칩n actual del rey.
            if piece[0] == "w":
                self.white_king_pos = (end_pos[0], end_pos[1]) # Actualiza la posici칩n del rey blanco.
            else:
                self.black_king_pos = (end_pos[0], end_pos[1]) # Actualiza la posici칩n del rey negro.

        # Verifica si el rey del color actual est치 en jaque despu칠s del movimiento simulado.
        king_in_check = rules.ChessRules.is_in_check(self, color)

        # --- Revertir el movimiento simulado para restaurar el estado del tablero ---
        self.board[start_row][start_col] = piece        # Devuelve la pieza a su casilla de inicio.
        self.board[end_pos[0]][end_pos[1]] = temp_piece # Restaura la pieza capturada (o vac칤a la casilla).
        if old_king_pos: # Si la posici칩n del rey fue actualizada temporalmente.
            if piece[0] == "w":
                self.white_king_pos = old_king_pos # Restaura la posici칩n original del rey blanco.
            else:
                self.black_king_pos = old_king_pos # Restaura la posici칩n original del rey negro.

        # El movimiento es v치lido si el rey no est치 en jaque despu칠s de realizarlo.
        return not king_in_check

    
    def is_check(self, color):
        """
        Verifica si el rey del color dado est치 en jaque.
        
        Args:
            color (str): 'w' para blancas o 'b' para negras.
            
        Returns:
            bool: True si el rey est치 en jaque, False en caso contrario.
        """
        return rules.ChessRules.is_in_check(self, color)
    
    def has_valid_moves(self, color):
        """
        Verifica si el jugador del color dado tiene al menos un movimiento legal.
        Esto es crucial para detectar jaque mate o ahogado.
        
        Args:
            color (str): 'w' para blancas o 'b' para negras.
            
        Returns:
            bool: True si tiene movimientos v치lidos, False en caso contrario.
        """
        from .utils import get_all_moves # Importa get_all_moves aqu칤 para evitar importaciones circulares.
        # Obtener todos los movimientos pseudo-legales del color (sin verificar jaque).
        moves = get_all_moves(self, color, pseudo_legal=True)

        # Probar si al menos uno de estos movimientos no deja al rey en jaque.
        for start, end in moves:
            start_piece = self.board[start[0]][start[1]] # Pieza en la casilla de inicio.
            captured = self.board[end[0]][end[1]]       # Pieza en la casilla de destino (posible captura).

            # Simular el movimiento.
            self.board[end[0]][end[1]] = start_piece # Mueve la pieza.
            self.board[start[0]][start[1]] = "--"    # Vac칤a la casilla de inicio.

            old_king_pos = None
            if start_piece[1] == "k": # Si la pieza movida es un rey.
                old_king_pos = self.white_king_pos if color == "w" else self.black_king_pos # Guarda la posici칩n actual del rey.
                if color == "w":
                    self.white_king_pos = end # Actualiza la posici칩n del rey blanco.
                else:
                    self.black_king_pos = end # Actualiza la posici칩n del rey negro.

            # Verifica si el rey est치 en jaque despu칠s del movimiento simulado.
            in_check = rules.ChessRules.is_in_check(self, color)

            # Revertir el movimiento simulado.
            self.board[start[0]][start[1]] = start_piece # Restaura la pieza a su posici칩n original.
            self.board[end[0]][end[1]] = captured       # Restaura la pieza capturada (o vac칤a la casilla).
            if old_king_pos: # Si la posici칩n del rey fue actualizada temporalmente.
                if color == "w":
                    self.white_king_pos = old_king_pos # Restaura la posici칩n original del rey blanco.
                else:
                    self.black_king_pos = old_king_pos # Restaura la posici칩n original del rey negro.

            if not in_check: # Si se encuentra un movimiento que no deja al rey en jaque.
                return True # El jugador tiene movimientos v치lidos.

        return False # No se encontraron movimientos v치lidos.
    
    def is_checkmate(self, color):
        """
        Devuelve True si el jugador del color dado est치 en jaque mate.
        Un jugador est치 en jaque mate si est치 en jaque y no tiene movimientos legales.
        
        Args:
            color (str): 'w' para blancas o 'b' para negras.
            
        Returns:
            bool: True si es jaque mate, False en caso contrario.
        """
        if self.is_check(color) and not self.has_valid_moves(color):
            return True
        return False
    
    def make_move(self, move: Move):
        """
        Aplica un movimiento en el tablero con soporte de reglas especiales.
        
        Args:
            move (Move): Objeto Move que describe el movimiento a realizar.
        """
        # Guardar estado antes del movimiento para poder deshacerlo.
        move.prev_castling_rights = self.castling_rights.copy() # Guarda una copia de los derechos de enroque.
        move.prev_en_passant = self.en_passant_square # Guarda la casilla de en passant.
        move.prev_white_king_pos = self.white_king_pos # Guarda la posici칩n del rey blanco.
        move.prev_black_king_pos = self.black_king_pos # Guarda la posici칩n del rey negro.

        # Movimiento normal: mueve la pieza de la casilla de inicio a la de destino.
        self.board[move.start_row][move.start_col] = "--" # Vac칤a la casilla de inicio.
        self.board[move.end_row][move.end_col] = move.piece_moved # Coloca la pieza movida en la casilla de destino.

        # 游댳 Actualizar posici칩n del rey si se mueve.
        if move.piece_moved[1] == "k": # Si la pieza movida es un rey.
            if move.piece_moved[0] == "w":
                self.white_king_pos = (move.end_row, move.end_col) # Actualiza la posici칩n del rey blanco.
            else:
                self.black_king_pos = (move.end_row, move.end_col) # Actualiza la posici칩n del rey negro.

        # 游댳 Promoci칩n de pe칩n.
        if move.is_pawn_promotion:
            # Reemplaza el pe칩n en la 칰ltima fila con la pieza elegida para la promoci칩n.
            self.board[move.end_row][move.end_col] = move.piece_moved[0] + move.promotion_choice

        # 游댳 Enroque.
        if move.is_castling:
            if move.end_col == 6:  # Enroque corto (lado del rey).
                self.board[move.end_row][5] = self.board[move.end_row][7] # Mueve la torre.
                self.board[move.end_row][7] = "--" # Vac칤a la casilla original de la torre.
            else:  # Enroque largo (lado de la reina).
                self.board[move.end_row][3] = self.board[move.end_row][0] # Mueve la torre.
                self.board[move.end_row][0] = "--" # Vac칤a la casilla original de la torre.

        # 游댳 En passant: Actualiza la casilla en_passant_square.
        self.en_passant_square = None # Por defecto, no hay casilla de en passant despu칠s de un movimiento.
        # Si un pe칩n se mueve dos casillas.
        if move.piece_moved[1] == "p" and abs(move.end_row - move.start_row) == 2:
            row = (move.start_row + move.end_row) // 2 # La casilla de en passant es la que el pe칩n "salt칩".
            col = move.start_col
            # Verifica si hay peones enemigos adyacentes que puedan realizar en passant.
            if (col > 0 and self.board[move.end_row][col-1][0:1] == ('b' if move.piece_moved[0] == 'w' else 'w')) or \
            (col < 7 and self.board[move.end_row][col+1][0:1] == ('b' if move.piece_moved[0] == 'w' else 'w')):
                self.en_passant_square = (row, col) # Establece la casilla de en passant.

        if move.is_en_passant:
            # Si el movimiento es un en passant, elimina el pe칩n capturado.
            direction = 1 if move.piece_moved[0] == "b" else -1 # Direcci칩n del movimiento del pe칩n.
            move.piece_captured = self.board[move.end_row - direction][move.end_col] # Guarda el pe칩n capturado.
            self.board[move.end_row - direction][move.end_col] = "--" # Elimina el pe칩n capturado.

        # 游댳 Actualizar derechos de enroque.
        # Si el rey se mueve, pierde ambos derechos de enroque.
        if move.piece_moved == "wk":
            self.castling_rights["wK"] = False
            self.castling_rights["wQ"] = False
        elif move.piece_moved == "bk":
            self.castling_rights["bK"] = False
            self.castling_rights["bQ"] = False
        # Si una torre se mueve de su posici칩n inicial, pierde el derecho de enroque de ese lado.
        elif move.piece_moved == "wr":
            if move.start_row == 7 and move.start_col == 0: # Torre blanca de la reina.
                self.castling_rights["wQ"] = False
            elif move.start_row == 7 and move.start_col == 7: # Torre blanca del rey.
                self.castling_rights["wK"] = False
        elif move.piece_moved == "br":
            if move.start_row == 0 and move.start_col == 0: # Torre negra de la reina.
                self.castling_rights["bQ"] = False
            elif move.start_row == 0 and move.start_col == 7: # Torre negra del rey.
                self.castling_rights["bK"] = False

        # Guardar el movimiento en el log y cambiar el turno.
        self.move_log.append(move) # A침ade el objeto Move al historial.
        self.turn = "b" if self.turn == "w" else "w" # Cambia el turno al otro color.


    def undo_move(self):
        """
        Revierte el 칰ltimo movimiento realizado en el tablero.
        """
        if not self.move_log: # Si no hay movimientos en el log, no hay nada que deshacer.
            return

        move = self.move_log.pop() # Obtiene el 칰ltimo movimiento del log.

        # Restaurar el tablero a su estado anterior al movimiento.
        self.board[move.start_row][move.start_col] = move.piece_moved # Devuelve la pieza movida a su origen.
        self.board[move.end_row][move.end_col] = move.piece_captured # Restaura la pieza capturada (o vac칤a la casilla).

        # 游댳 Revertir promoci칩n de pe칩n.
        if move.is_pawn_promotion:
            # Si hubo promoci칩n, la pieza en la casilla de inicio debe volver a ser un pe칩n.
            self.board[move.start_row][move.start_col] = move.piece_moved
            # La casilla de destino debe restaurar la pieza que estaba all칤 (o estar vac칤a).
            self.board[move.end_row][move.end_col] = move.piece_captured

        # 游댳 Revertir enroque.
        if move.is_castling:
            if move.end_col == 6:  # Enroque corto.
                self.board[move.end_row][7] = self.board[move.end_row][5] # Devuelve la torre a su posici칩n original.
                self.board[move.end_row][5] = "--" # Vac칤a la casilla donde estaba la torre despu칠s del enroque.
            else:  # Enroque largo.
                self.board[move.end_row][0] = self.board[move.end_row][3] # Devuelve la torre a su posici칩n original.
                self.board[move.end_row][3] = "--" # Vac칤a la casilla donde estaba la torre despu칠s del enroque.

        # 游댳 Revertir en passant.
        if move.is_en_passant:
            # Si fue un en passant, el pe칩n capturado debe ser restaurado.
            direction = 1 if move.piece_moved[0] == "b" else -1 # Direcci칩n del movimiento del pe칩n.
            self.board[move.end_row - direction][move.end_col] = move.piece_captured # Restaura el pe칩n capturado.
            self.board[move.end_row][move.end_col] = "--" # Vac칤a la casilla de destino del pe칩n que realiz칩 el en passant.

        # Restaurar posiciones de los reyes.
        self.white_king_pos = move.prev_white_king_pos # Restaura la posici칩n del rey blanco.
        self.black_king_pos = move.prev_black_king_pos # Restaura la posici칩n del rey negro.

        # Restaurar estados previos de derechos de enroque y en passant.
        self.castling_rights = move.prev_castling_rights # Restaura los derechos de enroque.
        self.en_passant_square = move.prev_en_passant # Restaura la casilla de en passant.

        # Revertir el turno.
        self.turn = "b" if self.turn == "w" else "w" # Cambia el turno de nuevo al color anterior.


    def is_game_over(self):
        """
        Verifica si el juego ha terminado por jaque mate o ahogado.
        
        Returns:
            bool: True si el juego ha terminado, False en caso contrario.
        """
        if self.is_checkmate("w") or self.is_checkmate("b"): # Si hay jaque mate para blancas o negras.
            return True
        if self.is_stalemate("w") or self.is_stalemate("b"): # Si hay ahogado para blancas o negras.
            return True
        return False
    
    def get_legal_moves(self, color=None):
        """
        Genera y devuelve una lista de todos los movimientos legales para el color especificado.
        Un movimiento es legal si no deja al propio rey en jaque.
        
        Args:
            color (str, optional): El color del jugador para el que se buscan movimientos.
                                   Por defecto, usa el turno actual.
                                   
        Returns:
            list: Una lista de objetos Move que representan los movimientos legales.
        """
        if color is None:
            color = self.turn  # Por defecto, usa el turno actual.

        legal_moves = [] # Lista para almacenar los movimientos legales.
        
        # Obtiene todos los movimientos pseudo-legales (que cumplen las reglas geom칠tricas).
        pseudo_moves = get_all_moves(self, color, pseudo_legal=False)

        # Filtrar los movimientos que dejen al rey en jaque.
        for move_tuple in pseudo_moves:
            # Crea un objeto Move a partir de la tupla (start_pos, end_pos).
            move = Move(move_tuple[0], move_tuple[1], self)
            
            self.make_move(move) # Simula el movimiento en el tablero.
            # Si despu칠s de hacer el movimiento, el rey del color actual NO est치 en jaque.
            if not ChessRules.is_in_check(self, color):
                legal_moves.append(move) # El movimiento es legal, a침치delo a la lista.
            self.undo_move() # Deshace el movimiento para restaurar el tablero.

        return legal_moves # Devuelve la lista de movimientos legales.

    def is_stalemate(self, current_turn):
        """
        Verifica si el juego est치 en ahogado (stalemate) para el turno actual.
        Ahogado: El jugador actual no tiene movimientos legales y no est치 en jaque.
        
        Args:
            current_turn (str): 'w' para blancas o 'b' para negras.
        
        Returns:
            bool: True si es ahogado, False otherwise.
        """
        # Verificar si el jugador actual no est치 en jaque. Si lo est치, no puede ser ahogado (ser칤a jaque mate si no hay movimientos).
        if self.is_check(current_turn):
            return False
        
        # Generar todos los movimientos legales para el jugador actual.
        legal_moves = self.get_legal_moves(current_turn)
        
        # Si no hay movimientos legales y no est치 en jaque, es ahogado.
        return len(legal_moves) == 0



    
